"""
PYTHON4WORK PROFESSIONAL - Interface Unificada Avan√ßada
Vers√£o profissional com logging, valida√ß√£o, temas e configura√ß√µes avan√ßadas.

Caracter√≠sticas Profissionais:
- Sistema de logging estruturado
- Valida√ß√£o robusta de dados
- Temas visuais personaliz√°veis
- Configura√ß√µes avan√ßadas
- Relat√≥rios detalhados
- Sistema de backup autom√°tico
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import pandas as pd
import os
import json
from datetime import datetime, timedelta
import threading
import time
import requests
from bs4 import BeautifulSoup
import re
import unicodedata
from dotenv import load_dotenv
import uuid
from pathlib import Path

# Importar sistemas profissionais
from config_manager import ConfigManager
from professional_logger import ProfessionalLogger
from data_validator import DataValidator
from theme_manager import ThemeManager

# Carrega as vari√°veis de ambiente
load_dotenv()

# Configura√ß√µes globais
LOGIN = os.getenv("LOGIN")
SENHA = os.getenv("SENHA")
URL = os.getenv("URL")
URL_DIVIDA = os.getenv("URL_DIVIDA")

class Python4WorkPro:
    def __init__(self, root):
        self.root = root
        self.session_id = str(uuid.uuid4())[:8]
        
        # Inicializar sistemas profissionais
        self.config = ConfigManager()
        self.logger = ProfessionalLogger("Python4WorkPro", self.config)
        self.validator = DataValidator(self.logger)
        self.theme_manager = ThemeManager()
        
        # Iniciar sess√£o de logging
        self.session_logger = self.logger.create_session_log(self.session_id)
        
        # Configurar tema
        self.theme_manager.set_theme(self.config.get('app.theme', 'modern'))
        
        # Vari√°veis de controle
        self.progresso_var = tk.IntVar()
        self.parar_flag = threading.Event()
        self.cancelar_flag = threading.Event()
        self.current_operation = None
        self.backup_counter = 0
        
        # Configurar janela principal
        self.configurar_janela()
        self.criar_interface_profissional()
        
        # Log in√≠cio da aplica√ß√£o
        self.logger.log_user_action("Aplica√ß√£o iniciada", session_id=self.session_id, theme=self.config.get('app.theme'))
    
    def configurar_janela(self):
        """Configura a janela principal com tema profissional"""
        # Configura√ß√µes da janela
        width = self.config.get('ui.window_width', 1000)
        height = self.config.get('ui.window_height', 700)
        
        self.root.title(f"{self.config.get('app.name', 'Python4Work Professional')} v{self.config.get('app.version', '2.0.0')}")
        self.root.geometry(f"{width}x{height}")
        self.root.minsize(800, 600)
        
        # Aplicar tema
        self.theme_manager.create_themed_window(self.root)
        
        # Centralizar janela
        self.root.update_idletasks()
        x = (self.root.winfo_screenwidth() // 2) - (width // 2)
        y = (self.root.winfo_screenheight() // 2) - (height // 2)
        self.root.geometry(f"{width}x{height}+{x}+{y}")
        
        # Configurar fechamento
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def criar_interface_profissional(self):
        """Cria interface profissional com layout moderno"""
        # Frame principal com scroll
        main_canvas = tk.Canvas(self.root)
        scrollbar = ttk.Scrollbar(self.root, orient="vertical", command=main_canvas.yview)
        self.scrollable_frame = ttk.Frame(main_canvas)
        
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: main_canvas.configure(scrollregion=main_canvas.bbox("all"))
        )
        
        main_canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        main_canvas.configure(yscrollcommand=scrollbar.set)
        
        # Header com informa√ß√µes da aplica√ß√£o
        self.criar_header()
        
        # Cards das funcionalidades
        self.criar_cards_funcionalidades()
        
        # √Årea de progresso (inicialmente oculta)
        self.criar_area_progresso()
        
        # Footer com informa√ß√µes de status
        self.criar_footer()
        
        # Configurar grid
        main_canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Bind scroll do mouse
        def _on_mousewheel(event):
            main_canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        main_canvas.bind_all("<MouseWheel>", _on_mousewheel)
    
    def criar_header(self):
        """Cria header profissional da aplica√ß√£o"""
        header_frame = self.theme_manager.create_card_frame(self.scrollable_frame)
        header_frame.pack(fill='x', padx=20, pady=(20, 10))
        
        # Container interno
        header_content = tk.Frame(header_frame, bg=self.theme_manager.get_color('surface'))
        header_content.pack(fill='x', padx=20, pady=20)
        
        # T√≠tulo principal
        title_label = tk.Label(header_content, 
                              text=f"üè¢ {self.config.get('app.name', 'Python4Work Professional')}", 
                              font=("Arial", 20, "bold"))
        self.theme_manager.apply_theme_to_widget(title_label, 'title')
        title_label.pack(anchor='w')
        
        # Subt√≠tulo
        subtitle_label = tk.Label(header_content, 
                                 text="Central Profissional de Automa√ß√£o de Processos",
                                 font=("Arial", 12))
        self.theme_manager.apply_theme_to_widget(subtitle_label, 'description')
        subtitle_label.pack(anchor='w', pady=(5, 0))
        
        # Informa√ß√µes da sess√£o
        info_frame = tk.Frame(header_content, bg=self.theme_manager.get_color('surface'))
        info_frame.pack(fill='x', pady=(15, 0))
        
        session_info = f"üìã Sess√£o: {self.session_id} | üé® Tema: {self.theme_manager.get_theme()['name']} | ‚ö° Vers√£o: {self.config.get('app.version', '2.0.0')}"
        info_label = tk.Label(info_frame, text=session_info, font=("Arial", 9))
        self.theme_manager.apply_theme_to_widget(info_label, 'description')
        info_label.pack(anchor='w')
        
        # Bot√µes de configura√ß√£o
        config_frame = tk.Frame(header_content, bg=self.theme_manager.get_color('surface'))
        config_frame.pack(fill='x', pady=(10, 0))
        
        # Bot√£o configura√ß√µes
        btn_config = tk.Button(config_frame, text="‚öôÔ∏è Configura√ß√µes", 
                              command=self.abrir_configuracoes,
                              font=("Arial", 9, "bold"), padx=15, pady=5)
        self.theme_manager.apply_theme_to_widget(btn_config, 'secondary_button')
        btn_config.pack(side='left', padx=(0, 10))
        
        # Bot√£o relat√≥rios
        btn_reports = tk.Button(config_frame, text="üìä Relat√≥rios", 
                               command=self.abrir_relatorios,
                               font=("Arial", 9, "bold"), padx=15, pady=5)
        self.theme_manager.apply_theme_to_widget(btn_reports, 'secondary_button')
        btn_reports.pack(side='left', padx=(0, 10))
        
        # Status de conectividade
        self.status_connectivity = tk.Label(config_frame, text="üîó Verificando conectividade...", 
                                           font=("Arial", 9))
        self.theme_manager.apply_theme_to_widget(self.status_connectivity, 'description')
        self.status_connectivity.pack(side='right')
        
        # Verificar conectividade em background
        threading.Thread(target=self.verificar_conectividade, daemon=True).start()
    
    def criar_cards_funcionalidades(self):
        """Cria cards das funcionalidades com design profissional e responsivo"""
        # Container dos cards
        cards_container = tk.Frame(self.scrollable_frame, bg=self.theme_manager.get_color('background'))
        cards_container.pack(fill='both', expand=True, padx=20, pady=10)
        
        # Configurar grid responsivo - 2 colunas em telas normais, 1 em telas pequenas
        cards_container.grid_rowconfigure(0, weight=1)
        cards_container.grid_rowconfigure(1, weight=1)
        cards_container.grid_columnconfigure(0, weight=1, minsize=300)  # Largura m√≠nima
        cards_container.grid_columnconfigure(1, weight=1, minsize=300)  # Largura m√≠nima
        
        # Defini√ß√£o dos cards
        funcionalidades = [
            {
                'titulo': 'üìã Consultar Acordo',
                'descricao': 'Consulta status de acordos usando c√≥digos de cliente e acordo',
                'icone': 'üìã',
                'cor': 'primary',
                'comando': self.abrir_consultar_acordo,
                'row': 0, 'col': 0
            },
            {
                'titulo': 'üîç Obter D√≠vida por CPF',
                'descricao': 'Obt√©m informa√ß√µes de d√≠vida ativa consultando por CPF',
                'icone': 'üîç',
                'cor': 'success',
                'comando': self.abrir_obter_divida,
                'row': 0, 'col': 1
            },
            {
                'titulo': 'üìÑ Extrair JSON',
                'descricao': 'Extrai e estrutura dados de campos JSON complexos',
                'icone': 'üìÑ',
                'cor': 'warning',
                'comando': self.abrir_extrair_json,
                'row': 1, 'col': 0
            },
            {
                'titulo': 'üìÅ Converter CSV ‚Üí XLSX',
                'descricao': 'Converte arquivos CSV para formato Excel com valida√ß√£o',
                'icone': 'üìÅ',
                'cor': 'accent',
                'comando': self.abrir_conversor,
                'row': 1, 'col': 1
            }
        ]
        
        # Criar cada card
        for func in funcionalidades:
            self.criar_card_funcionalidade(cards_container, func)
    
    def criar_card_funcionalidade(self, parent, config):
        """Cria um card individual de funcionalidade responsivo"""
        # Frame do card
        card = self.theme_manager.create_card_frame(parent)
        card.grid(row=config['row'], column=config['col'], 
                 padx=10, pady=10, sticky="nsew")
        
        # Container interno com padding reduzido para economizar espa√ßo
        card_content = tk.Frame(card, bg=self.theme_manager.get_color('surface'))
        card_content.pack(fill='both', expand=True, padx=15, pady=15)
        
        # Header com √≠cone e t√≠tulo em linha (mais compacto)
        header_frame = tk.Frame(card_content, bg=self.theme_manager.get_color('surface'))
        header_frame.pack(fill='x', pady=(0, 10))
        
        # √çcone m√©dio
        icon_label = tk.Label(header_frame, text=config['icone'], 
                             font=("Arial", 24), bg=self.theme_manager.get_color('surface'))
        icon_label.pack(side='left', padx=(0, 10))
        
        # T√≠tulo ao lado do √≠cone
        title_label = tk.Label(header_frame, text=config['titulo'], 
                              font=("Arial", 12, "bold"), anchor='w')
        self.theme_manager.apply_theme_to_widget(title_label, 'subtitle')
        title_label.pack(side='left', fill='x', expand=True)
        
        # Descri√ß√£o compacta
        desc_label = tk.Label(card_content, text=config['descricao'], 
                             font=("Arial", 9), wraplength=250, justify='left',
                             anchor='w')
        self.theme_manager.apply_theme_to_widget(desc_label, 'description')
        desc_label.pack(fill='x', pady=(0, 15))
        
        # Bot√£o principal menor
        btn = tk.Button(card_content, text="‚ñ∂ Iniciar", 
                       command=config['comando'],
                       font=("Arial", 10, "bold"), padx=15, pady=6)
        self.theme_manager.apply_theme_to_widget(btn, f"{config['cor']}_button")
        btn.pack(anchor='w')
        
        # Estat√≠sticas compactas
        stats_frame = tk.Frame(card_content, bg=self.theme_manager.get_color('surface'))
        stats_frame.pack(fill='x', pady=(10, 0))
        
        stats_label = tk.Label(stats_frame, text="üìä Pronto para uso", 
                              font=("Arial", 8), anchor='w')
        self.theme_manager.apply_theme_to_widget(stats_label, 'description')
        stats_label.pack(anchor='w')
    
    def criar_area_progresso(self):
        """Cria √°rea de progresso profissional"""
        self.frame_progresso = self.theme_manager.create_card_frame(self.scrollable_frame, "üìä Progresso da Opera√ß√£o")
        
        # Container interno
        progress_content = tk.Frame(self.frame_progresso, bg=self.theme_manager.get_color('surface'))
        progress_content.pack(fill='x', padx=20, pady=20)
        
        # Nome da opera√ß√£o atual
        self.label_operacao = tk.Label(progress_content, text="Nenhuma opera√ß√£o em andamento", 
                                      font=("Arial", 12, "bold"))
        self.theme_manager.apply_theme_to_widget(self.label_operacao, 'subtitle')
        self.label_operacao.pack(pady=(0, 15))
        
        # Barra de progresso principal
        self.progresso_bar = ttk.Progressbar(progress_content, variable=self.progresso_var, 
                                           maximum=100, length=600)
        self.progresso_bar.pack(pady=(0, 10))
        
        # Labels de progresso
        progress_info_frame = tk.Frame(progress_content, bg=self.theme_manager.get_color('surface'))
        progress_info_frame.pack(fill='x', pady=(0, 15))
        
        self.label_progresso = tk.Label(progress_info_frame, text="0/0 (0%)", 
                                      font=("Arial", 10, "bold"))
        self.theme_manager.apply_theme_to_widget(self.label_progresso, 'description')
        self.label_progresso.pack(side='left')
        
        self.label_tempo = tk.Label(progress_info_frame, text="Tempo: --", 
                                   font=("Arial", 10))
        self.theme_manager.apply_theme_to_widget(self.label_tempo, 'description')
        self.label_tempo.pack(side='right')
        
        # Status detalhado
        self.label_status = self.theme_manager.create_status_label(progress_content, "Pronto", "info")
        self.label_status.pack(pady=(0, 20))
        
        # Bot√µes de controle
        controls_frame = tk.Frame(progress_content, bg=self.theme_manager.get_color('surface'))
        controls_frame.pack(fill='x')
        
        self.btn_parar = tk.Button(controls_frame, text="‚è∏Ô∏è Pausar", 
                                  command=self.parar_processo, state="disabled",
                                  font=("Arial", 10, "bold"), padx=15, pady=8)
        self.theme_manager.apply_theme_to_widget(self.btn_parar, 'warning_button')
        self.btn_parar.pack(side="left", padx=(0, 10))
        
        self.btn_cancelar = tk.Button(controls_frame, text="‚ùå Cancelar", 
                                     command=self.cancelar_processo, state="disabled",
                                     font=("Arial", 10, "bold"), padx=15, pady=8)
        self.theme_manager.apply_theme_to_widget(self.btn_cancelar, 'danger_button')
        self.btn_cancelar.pack(side="left", padx=(0, 10))
        
        self.btn_voltar = tk.Button(controls_frame, text="üîô Voltar ao Menu", 
                                   command=self.voltar_menu,
                                   font=("Arial", 10, "bold"), padx=15, pady=8)
        self.theme_manager.apply_theme_to_widget(self.btn_voltar, 'secondary_button')
        self.btn_voltar.pack(side="right")
    
    def criar_footer(self):
        """Cria footer com informa√ß√µes do sistema"""
        footer_frame = tk.Frame(self.scrollable_frame, bg=self.theme_manager.get_color('light'), height=50)
        footer_frame.pack(fill='x', padx=20, pady=(10, 20))
        footer_frame.pack_propagate(False)
        
        # Informa√ß√µes do sistema
        system_info = f"üíª Python4Work Professional v{self.config.get('app.version', '2.0.0')} | üõ°Ô∏è Seguran√ßa: Ativa | üìù Logs: Habilitados"
        footer_label = tk.Label(footer_frame, text=system_info, 
                               font=("Arial", 8), bg=self.theme_manager.get_color('light'))
        footer_label.pack(expand=True)
    
    def mostrar_progresso(self, operacao_nome: str):
        """Mostra √°rea de progresso com nome da opera√ß√£o"""
        self.current_operation = operacao_nome
        self.label_operacao.config(text=f"üîÑ {operacao_nome}")
        self.frame_progresso.pack(fill='x', padx=20, pady=10)
        
        # Scroll para a √°rea de progresso
        self.root.update()
        self.scrollable_frame.update()
        
        self.logger.log_operation_start(operacao_nome, session_id=self.session_id)
    
    def atualizar_progresso(self, progresso, status="Processando..."):
        """Atualiza barra de progresso e status"""
        def _update():
            self.progresso_var.set(int(progresso))
            self.label_status.config(text=status)
            # Atualizar tempo estimado se necess√°rio
            if hasattr(self, 'start_time'):
                elapsed = time.time() - self.start_time
                self.label_tempo.config(text=f"Tempo: {elapsed:.1f}s")
        
        # Executar na thread principal
        self.root.after(0, _update)
    
    def ocultar_progresso(self):
        """Oculta √°rea de progresso"""
        self.frame_progresso.pack_forget()
        if self.current_operation:
            self.logger.log_operation_end(self.current_operation, session_id=self.session_id)
        self.current_operation = None
    
    def voltar_menu(self):
        """Volta para o menu principal"""
        self.parar_flag.set()
        self.cancelar_flag.set()
        self.ocultar_progresso()
        self.resetar_controles()
        self.logger.log_user_action("Voltou ao menu principal", session_id=self.session_id)
    
    def resetar_controles(self):
        """Reseta controles para estado inicial"""
        self.progresso_var.set(0)
        self.label_progresso.config(text="0/0 (0%)")
        self.label_tempo.config(text="Tempo: --")
        self.label_status.config(text="Pronto")
        self.btn_parar.config(state="disabled")
        self.btn_cancelar.config(state="disabled")
        self.parar_flag.clear()
        self.cancelar_flag.clear()
        self.backup_counter = 0
    
    def parar_processo(self):
        """Para processo salvando progresso"""
        self.parar_flag.set()
        self.label_status.config(text="‚è∏Ô∏è Pausando processo...")
        self.btn_parar.config(state="disabled")
        self.logger.log_user_action("Pausou processo", operation=self.current_operation, session_id=self.session_id)
    
    def cancelar_processo(self):
        """Cancela processo atual"""
        self.cancelar_flag.set()
        self.parar_flag.set()
        self.label_status.config(text="‚ùå Cancelando processo...")
        self.btn_parar.config(state="disabled")
        self.btn_cancelar.config(state="disabled")
        self.logger.log_user_action("Cancelou processo", operation=self.current_operation, session_id=self.session_id)
    
    def verificar_conectividade(self):
        """Verifica conectividade com APIs"""
        try:
            if LOGIN and SENHA and URL:
                # Teste r√°pido de conectividade
                response = requests.get("http://54.83.29.48", timeout=5)
                self.root.after(0, lambda: self.status_connectivity.config(text="üü¢ Conectado"))
                self.logger.info("Conectividade verificada", status="success")
            else:
                self.root.after(0, lambda: self.status_connectivity.config(text="üü° Configura√ß√£o incompleta"))
                self.logger.warning("Vari√°veis de ambiente incompletas")
        except:
            self.root.after(0, lambda: self.status_connectivity.config(text="üî¥ Offline"))
            self.logger.warning("Falha na verifica√ß√£o de conectividade")
    
    def abrir_configuracoes(self):
        """Abre janela de configura√ß√µes FUNCIONAL"""
        self.logger.log_user_action("Abriu configura√ß√µes", session_id=self.session_id)
        
        # Criar janela de configura√ß√µes
        config_window = tk.Toplevel(self.root)
        config_window.title("‚öôÔ∏è Configura√ß√µes")
        config_window.geometry("500x400")
        config_window.transient(self.root)
        config_window.grab_set()
        
        # Aplicar tema
        config_window.configure(bg=self.theme_manager.get_color('background'))
        
        # Frame principal
        main_frame = tk.Frame(config_window, bg=self.theme_manager.get_color('background'))
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # T√≠tulo
        title_label = tk.Label(main_frame, text="‚öôÔ∏è Configura√ß√µes da Aplica√ß√£o", 
                              font=("Arial", 14, "bold"))
        self.theme_manager.apply_theme_to_widget(title_label, 'title')
        title_label.pack(pady=(0, 20))
        
        # Configura√ß√µes de tema
        theme_frame = tk.LabelFrame(main_frame, text="üé® Tema Visual", 
                                   font=("Arial", 10, "bold"), padx=10, pady=10)
        self.theme_manager.apply_theme_to_widget(theme_frame, 'surface')
        theme_frame.pack(fill='x', pady=(0, 15))
        
        current_theme = self.config.get('app.theme', 'modern')
        theme_var = tk.StringVar(value=current_theme)
        
        themes = [("üåü Moderno", "modern"), ("üåô Escuro", "dark"), 
                 ("üè¢ Corporativo", "corporate"), ("üåø Natureza", "nature")]
        
        for text, value in themes:
            rb = tk.Radiobutton(theme_frame, text=text, variable=theme_var, value=value,
                               command=lambda v=value: self.aplicar_tema(v))
            self.theme_manager.apply_theme_to_widget(rb, 'surface')
            rb.pack(anchor='w')
        
        # Configura√ß√µes de logging
        log_frame = tk.LabelFrame(main_frame, text="üìù Sistema de Logging", 
                                 font=("Arial", 10, "bold"), padx=10, pady=10)
        self.theme_manager.apply_theme_to_widget(log_frame, 'surface')
        log_frame.pack(fill='x', pady=(0, 15))
        
        log_level_var = tk.StringVar(value=self.config.get('logging.level', 'INFO'))
        log_levels = [("üîç DEBUG", "DEBUG"), ("‚ÑπÔ∏è INFO", "INFO"), ("‚ö†Ô∏è WARNING", "WARNING")]
        
        for text, value in log_levels:
            rb = tk.Radiobutton(log_frame, text=text, variable=log_level_var, value=value)
            self.theme_manager.apply_theme_to_widget(rb, 'surface')
            rb.pack(anchor='w')
        
        # Bot√µes
        button_frame = tk.Frame(main_frame, bg=self.theme_manager.get_color('background'))
        button_frame.pack(fill='x', pady=(20, 0))
        
        def salvar_config():
            self.config.set('app.theme', theme_var.get())
            self.config.set('logging.level', log_level_var.get())
            messagebox.showinfo("Sucesso", "Configura√ß√µes salvas!\nReinicie para aplicar todas as mudan√ßas.")
            config_window.destroy()
        
        btn_salvar = tk.Button(button_frame, text="üíæ Salvar", command=salvar_config,
                              font=("Arial", 10, "bold"), padx=20)
        self.theme_manager.apply_theme_to_widget(btn_salvar, 'primary_button')
        btn_salvar.pack(side='right', padx=(10, 0))
        
        btn_cancelar = tk.Button(button_frame, text="‚ùå Cancelar", 
                                command=config_window.destroy,
                                font=("Arial", 10, "bold"), padx=20)
        self.theme_manager.apply_theme_to_widget(btn_cancelar, 'secondary_button')
        btn_cancelar.pack(side='right')
    
    def aplicar_tema(self, tema):
        """Aplica tema imediatamente em toda a interface"""
        self.theme_manager.set_theme(tema)
        self.config.set('app.theme', tema)
        
        # Aplicar tema a toda a interface principal
        self.root.configure(bg=self.theme_manager.get_color('background'))
        
        # Atualizar todos os widgets principais
        try:
            # Reconfigurar scrollable_frame
            if hasattr(self, 'scrollable_frame'):
                self.scrollable_frame.configure(bg=self.theme_manager.get_color('background'))
            
            # Atualizar todos os widgets filhos recursivamente
            self._atualizar_tema_recursivo(self.root)
            
            # Salvar configura√ß√£o
            self.logger.info(f"Tema alterado para: {tema}")
            
        except Exception as e:
            self.logger.error(f"Erro ao aplicar tema: {e}")
    
    def _atualizar_tema_recursivo(self, widget):
        """Atualiza tema recursivamente em todos os widgets"""
        try:
            # Aplicar cor de fundo padr√£o
            if widget.winfo_class() in ['Frame', 'Toplevel']:
                widget.configure(bg=self.theme_manager.get_color('background'))
            elif widget.winfo_class() == 'Canvas':
                widget.configure(bg=self.theme_manager.get_color('background'))
                
            # Processar todos os filhos
            for child in widget.winfo_children():
                self._atualizar_tema_recursivo(child)
                
        except Exception:
            pass  # Ignorar erros de widgets que n√£o suportam configura√ß√£o
        
    def abrir_relatorios(self):
        """Abre janela de relat√≥rios FUNCIONAL"""
        self.logger.log_user_action("Abriu relat√≥rios", session_id=self.session_id)
        
        # Criar janela de relat√≥rios
        report_window = tk.Toplevel(self.root)
        report_window.title("üìä Relat√≥rios e Logs")
        report_window.geometry("700x500")
        report_window.transient(self.root)
        report_window.grab_set()
        
        # Aplicar tema
        report_window.configure(bg=self.theme_manager.get_color('background'))
        
        # Frame principal
        main_frame = tk.Frame(report_window, bg=self.theme_manager.get_color('background'))
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # T√≠tulo
        title_label = tk.Label(main_frame, text="üìä Relat√≥rios do Sistema", 
                              font=("Arial", 14, "bold"))
        self.theme_manager.apply_theme_to_widget(title_label, 'title')
        title_label.pack(pady=(0, 20))
        
        # Notebook para abas
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill='both', expand=True)
        
        # Aba 1: Logs Recentes
        log_frame = tk.Frame(notebook, bg=self.theme_manager.get_color('surface'))
        notebook.add(log_frame, text="üìù Logs Recentes")
        
        log_text = tk.Text(log_frame, height=15, wrap='word')
        log_scroll = tk.Scrollbar(log_frame, orient="vertical", command=log_text.yview)
        log_text.configure(yscrollcommand=log_scroll.set)
        
        try:
            with open("logs/python4workpro.log", "r", encoding="utf-8") as f:
                logs = f.readlines()[-50:]  # √öltimas 50 linhas
                log_text.insert(tk.END, "".join(logs))
        except:
            log_text.insert(tk.END, "Nenhum log encontrado.")
        
        log_text.pack(side='left', fill='both', expand=True, padx=(10, 0), pady=10)
        log_scroll.pack(side='right', fill='y', pady=10, padx=(0, 10))
        
        # Aba 2: Estat√≠sticas
        stats_frame = tk.Frame(notebook, bg=self.theme_manager.get_color('surface'))
        notebook.add(stats_frame, text="üìà Estat√≠sticas")
        
        stats_text = tk.Text(stats_frame, height=15, wrap='word')
        
        # Gerar estat√≠sticas b√°sicas
        stats_info = f"""üìä ESTAT√çSTICAS DO SISTEMA
        
üïê Sess√£o Atual: {self.session_id}
üìÖ Data/Hora: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}
üé® Tema Ativo: {self.config.get('app.theme', 'modern')}
üìù N√≠vel de Log: {self.config.get('logging.level', 'INFO')}

üìÅ ARQUIVOS DE LOG:
- Log Principal: logs/python4workpro.log
- Log de Erros: logs/python4workpro_errors.log
- Sess√µes: logs/sessions/

‚öôÔ∏è CONFIGURA√á√ïES:
- Auto Backup: {self.config.get('app.auto_backup', True)}
- Confirmar Sa√≠da: {self.config.get('ui.confirm_exit', True)}
- Tentativas Max: {self.config.get('app.max_retries', 3)}

üîß SISTEMA:
- Python4Work Professional v{self.config.get('app.version', '2.0.0')}
- Interface: Profissional
- Status: Ativo ‚úÖ
"""
        
        stats_text.insert(tk.END, stats_info)
        stats_text.config(state='disabled')
        stats_text.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Bot√µes na janela
        button_frame = tk.Frame(main_frame, bg=self.theme_manager.get_color('background'))
        button_frame.pack(fill='x', pady=(10, 0))
        
        def abrir_pasta_logs():
            import subprocess
            subprocess.run(['explorer', os.path.abspath('logs')], shell=True)
        
        btn_logs = tk.Button(button_frame, text="üìÅ Abrir Pasta Logs", 
                            command=abrir_pasta_logs, font=("Arial", 10))
        self.theme_manager.apply_theme_to_widget(btn_logs, 'primary_button')
        btn_logs.pack(side='left')
        
        btn_fechar = tk.Button(button_frame, text="‚ùå Fechar", 
                              command=report_window.destroy, font=("Arial", 10))
        self.theme_manager.apply_theme_to_widget(btn_fechar, 'secondary_button')
        btn_fechar.pack(side='right')
    
    def on_closing(self):
        """Trata fechamento da aplica√ß√£o"""
        if self.config.get('ui.confirm_exit', True):
            if messagebox.askyesno("Confirmar", "Deseja realmente sair?"):
                self.finalizar_aplicacao()
        else:
            self.finalizar_aplicacao()
    
    def finalizar_aplicacao(self):
        """Finaliza aplica√ß√£o de forma limpa"""
        # Parar processos em andamento
        self.parar_flag.set()
        self.cancelar_flag.set()
        
        # Finalizar sess√£o de logging
        if hasattr(self, 'session_logger'):
            summary = {
                "operations_performed": bool(self.current_operation),
                "clean_exit": True
            }
            self.session_logger.finalize_session(summary)
        
        self.logger.log_user_action("Aplica√ß√£o finalizada", session_id=self.session_id)
        
        # Salvar configura√ß√µes se necess√°rio
        self.config.save_config()
        
        # Fechar aplica√ß√£o
        self.root.destroy()
    
    # === FUNCIONALIDADES IMPLEMENTADAS ===
    
    def abrir_consultar_acordo(self):
        """Funcionalidade consultar acordo com op√ß√£o de baixar modelo"""
        self.mostrar_progresso("Consultar Acordo")
        self.logger.log_user_action("Iniciou Consultar Acordo", session_id=self.session_id)
        
        # Habilitar controles
        self.btn_parar.config(state="normal")
        self.btn_cancelar.config(state="normal")
        
        # Janela de op√ß√µes
        opcao = messagebox.askyesnocancel(
            "Consultar Acordo",
            "Escolha uma op√ß√£o:\n\n"
            "‚úÖ SIM - Baixar modelo Excel primeiro\n"
            "‚ùå N√ÉO - Usar arquivo existente\n"
            "üö´ CANCELAR - Voltar ao menu"
        )
        
        if opcao is None:  # Cancelar
            self.voltar_menu()
            return
        elif opcao:  # Baixar modelo
            self.baixar_modelo_consultar_acordo()
            return
        
        # Continuar com arquivo existente
        self.selecionar_arquivo_consultar_acordo()
    
    def baixar_modelo_consultar_acordo(self):
        """Baixa modelo Excel para consultar acordo"""
        import shutil
        
        arquivo_modelo = filedialog.asksaveasfilename(
            title="Salvar modelo Excel - Consultar Acordo",
            defaultextension=".xlsx",
            filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")],
            initialfile="modelo_consultar_acordo.xlsx"
        )
        
        if not arquivo_modelo:
            self.voltar_menu()
            return
        
        try:
            # Copiar modelo da pasta Modelos
            modelo_origem = "Modelos/modelo_consultar_acordo.xlsx"
            
            if not os.path.exists(modelo_origem):
                messagebox.showerror("Erro", f"Modelo n√£o encontrado: {modelo_origem}")
                self.voltar_menu()
                return
                
            shutil.copy2(modelo_origem, arquivo_modelo)
            
            messagebox.showinfo(
                "Modelo Copiado", 
                f"Modelo Excel copiado com sucesso!\n\n"
                f"üìÅ Arquivo: {arquivo_modelo}\n\n"
                f"üìã Colunas necess√°rias:\n"
                f"‚Ä¢ cod_cliente (n√∫meros)\n"
                f"‚Ä¢ cod_acordo (n√∫meros)\n"
                f"‚Ä¢ observacoes (texto)\n\n"
                f"‚úÖ Preencha os dados e execute novamente!"
            )
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao copiar modelo: {e}")
        
        self.voltar_menu()
    
    def selecionar_arquivo_consultar_acordo(self):
        """Seleciona arquivo para consultar acordo"""
        # Sele√ß√£o de arquivo
        arquivo_entrada = filedialog.askopenfilename(
            title="Selecione o arquivo Excel com cod_cliente e cod_acordo",
            filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
        
        if not arquivo_entrada:
            self.voltar_menu()
            return
        
        # Sele√ß√£o de local para salvar
        arquivo_saida = filedialog.asksaveasfilename(
            title="Onde salvar o resultado?",
            defaultextension=".xlsx",
            filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
        
        if not arquivo_saida:
            self.voltar_menu()
            return
        
        # Executar em thread separada
        thread = threading.Thread(target=self.executar_consultar_acordo, 
                                args=(arquivo_entrada, arquivo_saida))
        thread.daemon = True
        thread.start()
    
    def executar_consultar_acordo(self, arquivo_entrada, arquivo_saida):
        """Executa consulta de acordo"""
        try:
            # Importar fun√ß√£o do script original
            from consultar_acordo import consultar_status_acordo
            
            # Ler arquivo
            df = pd.read_excel(arquivo_entrada)
            total_linhas = len(df)
            
            self.atualizar_progresso(0, f"Iniciando processamento de {total_linhas} registros...")
            
            # Verificar colunas necess√°rias
            if not all(col in df.columns for col in ['cod_cliente', 'cod_acordo']):
                messagebox.showerror("Erro", "Arquivo deve conter colunas 'cod_cliente' e 'cod_acordo'")
                self.voltar_menu()
                return
            
            # Adicionar coluna de status se n√£o existir
            if 'status_acordo' not in df.columns:
                df['status_acordo'] = ''
            
            # Processar cada linha
            for idx, row in df.iterrows():
                if self.cancelar_flag.is_set():
                    break
                
                if self.parar_flag.is_set():
                    self.atualizar_progresso((idx/total_linhas)*100, "Processo pausado...")
                    self.parar_flag.wait()
                
                try:
                    cod_cliente = str(row['cod_cliente']).strip()
                    cod_acordo = str(row['cod_acordo']).strip()
                    
                    # Consultar acordo (fun√ß√£o espera row e index)
                    status = consultar_status_acordo(row, idx)
                    df.at[idx, 'status_acordo'] = status
                    
                    # Atualizar progresso
                    progresso = ((idx + 1) / total_linhas) * 100
                    self.atualizar_progresso(progresso, f"Processando linha {idx + 1}/{total_linhas}")
                    
                    # Salvar periodicamente
                    if (idx + 1) % 5 == 0:
                        df.to_excel(arquivo_saida, index=False)
                    
                except Exception as e:
                    self.logger.error(f"Erro na linha {idx + 1}: {e}")
                    df.at[idx, 'status_acordo'] = f"ERRO: {str(e)}"
            
            # Salvar resultado final
            df.to_excel(arquivo_saida, index=False)
            
            if not self.cancelar_flag.is_set():
                self.atualizar_progresso(100, "Processamento conclu√≠do!")
                messagebox.showinfo("Sucesso", f"Arquivo salvo: {arquivo_saida}")
            
        except Exception as e:
            self.logger.critical(f"Erro cr√≠tico em consultar acordo: {e}")
            messagebox.showerror("Erro", f"Erro no processamento: {e}")
        
        finally:
            self.voltar_menu()
    
    def abrir_obter_divida(self):
        """Funcionalidade obter d√≠vida com op√ß√£o de baixar modelo"""
        self.mostrar_progresso("Obter D√≠vida por CPF")
        self.logger.log_user_action("Iniciou Obter D√≠vida", session_id=self.session_id)
        
        # Habilitar controles
        self.btn_parar.config(state="normal")
        self.btn_cancelar.config(state="normal")
        
        # Janela de op√ß√µes
        opcao = messagebox.askyesnocancel(
            "Obter D√≠vida por CPF",
            "Escolha uma op√ß√£o:\n\n"
            "‚úÖ SIM - Baixar modelo Excel primeiro\n"
            "‚ùå N√ÉO - Usar arquivo existente\n"
            "üö´ CANCELAR - Voltar ao menu"
        )
        
        if opcao is None:  # Cancelar
            self.voltar_menu()
            return
        elif opcao:  # Baixar modelo
            self.baixar_modelo_obter_divida()
            return
        
        # Continuar com arquivo existente
        self.selecionar_arquivo_obter_divida()
    
    def baixar_modelo_obter_divida(self):
        """Baixa modelo Excel para obter d√≠vida por CPF"""
        import shutil
        
        arquivo_modelo = filedialog.asksaveasfilename(
            title="Salvar modelo Excel - Obter D√≠vida CPF",
            defaultextension=".xlsx",
            filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")],
            initialfile="modelo_obter_divida_cpf.xlsx"
        )
        
        if not arquivo_modelo:
            self.voltar_menu()
            return
        
        try:
            # Copiar modelo da pasta Modelos
            modelo_origem = "Modelos/modelo_obter_divida_cpf.xlsx"
            
            if not os.path.exists(modelo_origem):
                messagebox.showerror("Erro", f"Modelo n√£o encontrado: {modelo_origem}")
                self.voltar_menu()
                return
                
            shutil.copy2(modelo_origem, arquivo_modelo)
            
            messagebox.showinfo(
                "Modelo Copiado", 
                f"Modelo Excel copiado com sucesso!\n\n"
                f"üìÅ Arquivo: {arquivo_modelo}\n\n"
                f"üìã Colunas necess√°rias:\n"
                f"‚Ä¢ cpf (11 d√≠gitos)\n"
                f"‚Ä¢ nome (texto)\n"
                f"‚Ä¢ observacoes (texto)\n\n"
                f"‚úÖ Preencha os dados e execute novamente!"
            )
            
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao copiar modelo: {e}")
        
        self.voltar_menu()
    
    def selecionar_arquivo_obter_divida(self):
        """Seleciona arquivo para obter d√≠vida"""
        # Sele√ß√£o de arquivo
        arquivo_entrada = filedialog.askopenfilename(
            title="Selecione o arquivo Excel com CPFs",
            filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
        
        if not arquivo_entrada:
            self.voltar_menu()
            return
        
        # Sele√ß√£o de local para salvar
        arquivo_saida = filedialog.asksaveasfilename(
            title="Onde salvar o resultado?",
            defaultextension=".xlsx",
            filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
        
        if not arquivo_saida:
            self.voltar_menu()
            return
        
        # Executar em thread separada
        thread = threading.Thread(target=self.executar_obter_divida, 
                                args=(arquivo_entrada, arquivo_saida))
        thread.daemon = True
        thread.start()
    
    def executar_obter_divida(self, arquivo_entrada, arquivo_saida):
        """Executa obten√ß√£o de d√≠vida por CPF"""
        try:
            # Importar fun√ß√£o do script original
            from obter_divida_cpf import consultar_easycollector
            
            # Ler arquivo
            df = pd.read_excel(arquivo_entrada)
            total_linhas = len(df)
            
            self.atualizar_progresso(0, f"Iniciando processamento de {total_linhas} CPFs...")
            
            # Verificar coluna CPF
            if 'cpf' not in df.columns:
                messagebox.showerror("Erro", "Arquivo deve conter coluna 'cpf'")
                self.voltar_menu()
                return
            
            # Adicionar colunas de resultado se n√£o existirem
            for col in ['cod_cliente', 'cod_acordo', 'status', 'observacao']:
                if col not in df.columns:
                    df[col] = ''
            
            # Processar cada linha
            for idx, row in df.iterrows():
                if self.cancelar_flag.is_set():
                    break
                
                if self.parar_flag.is_set():
                    self.atualizar_progresso((idx/total_linhas)*100, "Processo pausado...")
                    self.parar_flag.wait()
                
                try:
                    cpf = str(row['cpf']).strip()
                    
                    # Validar CPF
                    if not self.validator.validate_cpf(cpf):
                        df.at[idx, 'status'] = 'CPF Inv√°lido'
                        df.at[idx, 'observacao'] = 'CPF n√£o passou na valida√ß√£o'
                        continue
                    
                    # Consultar d√≠vida
                    resultado = consultar_easycollector(cpf, LOGIN, SENHA)
                    
                    if resultado and len(resultado) >= 4:
                        df.at[idx, 'cod_cliente'] = resultado[0]
                        df.at[idx, 'cod_acordo'] = resultado[1]
                        df.at[idx, 'status'] = resultado[2]
                        df.at[idx, 'observacao'] = resultado[3]
                    else:
                        df.at[idx, 'status'] = 'N√£o encontrado'
                        df.at[idx, 'observacao'] = 'CPF n√£o retornou dados'
                    
                    # Atualizar progresso
                    progresso = ((idx + 1) / total_linhas) * 100
                    self.atualizar_progresso(progresso, f"Processando CPF {idx + 1}/{total_linhas}")
                    
                    # Salvar periodicamente
                    if (idx + 1) % 5 == 0:
                        df.to_excel(arquivo_saida, index=False)
                    
                except Exception as e:
                    self.logger.error(f"Erro no CPF linha {idx + 1}: {e}")
                    df.at[idx, 'status'] = 'ERRO'
                    df.at[idx, 'observacao'] = f"Erro: {str(e)}"
            
            # Salvar resultado final
            df.to_excel(arquivo_saida, index=False)
            
            if not self.cancelar_flag.is_set():
                self.atualizar_progresso(100, "Processamento conclu√≠do!")
                messagebox.showinfo("Sucesso", f"Arquivo salvo: {arquivo_saida}")
            
        except Exception as e:
            self.logger.critical(f"Erro cr√≠tico em obter d√≠vida: {e}")
            messagebox.showerror("Erro", f"Erro no processamento: {e}")
        
        finally:
            self.voltar_menu()
    
    def abrir_extrair_json(self):
        """Funcionalidade extrair JSON - IMPLEMENTA√á√ÉO COMPLETA"""
        self.mostrar_progresso("Extrair JSON")
        self.logger.log_user_action("Iniciou Extrair JSON", session_id=self.session_id)
        
        # Habilitar controles
        self.btn_parar.config(state="normal")
        self.btn_cancelar.config(state="normal")
        
        # Sele√ß√£o de arquivo
        arquivo_entrada = filedialog.askopenfilename(
            title="Selecione o arquivo Excel com dados JSON",
            filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
        
        if not arquivo_entrada:
            self.voltar_menu()
            return
        
        # Sele√ß√£o de local para salvar
        arquivo_saida = filedialog.asksaveasfilename(
            title="Onde salvar o resultado?",
            defaultextension=".xlsx",
            filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
        
        if not arquivo_saida:
            self.voltar_menu()
            return
        
        # Executar em thread separada
        thread = threading.Thread(target=self.executar_extrair_json, 
                                args=(arquivo_entrada, arquivo_saida))
        thread.daemon = True
        thread.start()
    
    def executar_extrair_json(self, arquivo_entrada, arquivo_saida):
        """Executa extra√ß√£o de dados JSON"""
        try:
            # Ler arquivo
            df = pd.read_excel(arquivo_entrada)
            total_linhas = len(df)
            
            self.atualizar_progresso(0, f"Iniciando extra√ß√£o de {total_linhas} registros JSON...")
            
            # Verificar coluna corpo_requisicao
            if 'corpo_requisicao' not in df.columns:
                messagebox.showerror("Erro", "Arquivo deve conter coluna 'corpo_requisicao'")
                self.voltar_menu()
                return
            
            # Processar dados JSON
            registros = []
            
            for idx, row in df.iterrows():
                if self.cancelar_flag.is_set():
                    break
                
                if self.parar_flag.is_set():
                    self.atualizar_progresso((idx/total_linhas)*100, "Processo pausado...")
                    self.parar_flag.wait()
                
                try:
                    corpo_requisicao = row['corpo_requisicao']
                    
                    # Tentar extrair JSON
                    if pd.notna(corpo_requisicao) and corpo_requisicao.strip():
                        try:
                            dados_json = json.loads(corpo_requisicao)
                            
                            # Extrair campos principais
                            registro = {'linha_original': idx + 1}
                            
                            # Fun√ß√£o recursiva para extrair dados
                            def extrair_campos(data, prefix=""):
                                if isinstance(data, dict):
                                    for key, value in data.items():
                                        new_key = f"{prefix}{key}" if prefix else key
                                        if isinstance(value, (dict, list)):
                                            extrair_campos(value, f"{new_key}_")
                                        else:
                                            registro[new_key] = value
                                elif isinstance(data, list):
                                    for i, item in enumerate(data):
                                        extrair_campos(item, f"{prefix}{i}_")
                            
                            extrair_campos(dados_json)
                            registros.append(registro)
                            
                        except json.JSONDecodeError:
                            # JSON inv√°lido
                            registro = {
                                'linha_original': idx + 1,
                                'erro': 'JSON inv√°lido',
                                'corpo_original': str(corpo_requisicao)[:100]
                            }
                            registros.append(registro)
                    else:
                        # Vazio
                        registro = {
                            'linha_original': idx + 1,
                            'erro': 'Campo vazio'
                        }
                        registros.append(registro)
                    
                    # Atualizar progresso
                    progresso = ((idx + 1) / total_linhas) * 100
                    self.atualizar_progresso(progresso, f"Processando JSON {idx + 1}/{total_linhas}")
                    
                except Exception as e:
                    self.logger.error(f"Erro na linha {idx + 1}: {e}")
                    registro = {
                        'linha_original': idx + 1,
                        'erro': f"Erro: {str(e)}"
                    }
                    registros.append(registro)
            
            # Criar DataFrame com resultados
            if registros:
                resultado_df = pd.DataFrame(registros)
                resultado_df.to_excel(arquivo_saida, index=False)
                
                if not self.cancelar_flag.is_set():
                    self.atualizar_progresso(100, "Extra√ß√£o conclu√≠da!")
                    messagebox.showinfo("Sucesso", f"Dados extra√≠dos e salvos: {arquivo_saida}")
            else:
                messagebox.showwarning("Aviso", "Nenhum dado foi extra√≠do")
            
        except Exception as e:
            self.logger.critical(f"Erro cr√≠tico em extrair JSON: {e}")
            messagebox.showerror("Erro", f"Erro na extra√ß√£o: {e}")
        
        finally:
            self.voltar_menu()
    
    def abrir_conversor(self):
        """Funcionalidade conversor - IMPLEMENTA√á√ÉO COMPLETA"""
        self.mostrar_progresso("Converter CSV ‚Üí XLSX")
        self.logger.log_user_action("Iniciou Conversor", session_id=self.session_id)
        
        # Habilitar controles
        self.btn_parar.config(state="normal")
        self.btn_cancelar.config(state="normal")
        
        # Sele√ß√£o de arquivos CSV
        arquivos_csv = filedialog.askopenfilenames(
            title="Selecione os arquivos CSV para converter",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        
        if not arquivos_csv:
            self.voltar_menu()
            return
        
        # Sele√ß√£o de pasta de destino
        pasta_destino = filedialog.askdirectory(
            title="Selecione a pasta onde salvar os arquivos Excel"
        )
        
        if not pasta_destino:
            self.voltar_menu()
            return
        
        # Executar em thread separada
        thread = threading.Thread(target=self.executar_conversor, 
                                args=(arquivos_csv, pasta_destino))
        thread.daemon = True
        thread.start()
    
    def executar_conversor(self, arquivos_csv, pasta_destino):
        """Executa convers√£o CSV para XLSX"""
        try:
            total_arquivos = len(arquivos_csv)
            self.atualizar_progresso(0, f"Convertendo {total_arquivos} arquivos...")
            
            arquivos_convertidos = []
            erros = []
            
            for idx, arquivo_csv in enumerate(arquivos_csv):
                if self.cancelar_flag.is_set():
                    break
                
                try:
                    # Detectar delimitador
                    delimitador = ','
                    try:
                        with open(arquivo_csv, 'r', encoding='utf-8') as f:
                            primeira_linha = f.readline()
                            if ';' in primeira_linha:
                                delimitador = ';'
                            elif '\t' in primeira_linha:
                                delimitador = '\t'
                    except:
                        pass
                    
                    # Ler CSV
                    df = pd.read_csv(arquivo_csv, delimiter=delimitador, encoding='utf-8')
                    
                    # Limpar cabe√ßalhos
                    df.columns = df.columns.str.strip().str.replace('"', '').str.replace("'", '')
                    
                    # Nome do arquivo de sa√≠da
                    nome_base = os.path.splitext(os.path.basename(arquivo_csv))[0]
                    arquivo_xlsx = os.path.join(pasta_destino, f"{nome_base}.xlsx")
                    
                    # Salvar como Excel
                    df.to_excel(arquivo_xlsx, index=False)
                    arquivos_convertidos.append(arquivo_xlsx)
                    
                    # Atualizar progresso
                    progresso = ((idx + 1) / total_arquivos) * 100
                    self.atualizar_progresso(progresso, f"Convertido: {nome_base}.xlsx")
                    
                except Exception as e:
                    self.logger.error(f"Erro ao converter {arquivo_csv}: {e}")
                    erros.append(f"{os.path.basename(arquivo_csv)}: {str(e)}")
            
            if not self.cancelar_flag.is_set():
                self.atualizar_progresso(100, "Convers√£o conclu√≠da!")
                
                mensagem = f"Convertidos {len(arquivos_convertidos)} arquivos para:\n{pasta_destino}"
                if erros:
                    mensagem += f"\n\nErros encontrados:\n" + "\n".join(erros[:5])
                    if len(erros) > 5:
                        mensagem += f"\n... e mais {len(erros) - 5} erros"
                
                messagebox.showinfo("Convers√£o Conclu√≠da", mensagem)
            
        except Exception as e:
            self.logger.critical(f"Erro cr√≠tico no conversor: {e}")
            messagebox.showerror("Erro", f"Erro na convers√£o: {e}")
        
        finally:
            self.voltar_menu()

def main():
    """Fun√ß√£o principal"""
    root = tk.Tk()
    app = Python4WorkPro(root)
    
    try:
        root.mainloop()
    except Exception as e:
        if hasattr(app, 'logger'):
            app.logger.critical("Erro cr√≠tico na aplica√ß√£o", exception=e)
        else:
            print(f"Erro cr√≠tico: {e}")

if __name__ == "__main__":
    main()
